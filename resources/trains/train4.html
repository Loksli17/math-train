<script src="models/SetModel.js" charset="utf-8"></script>
<script src="models/OperationModel.js" charset="utf-8"></script>
<script src="models/AlgebraModel.js" charset="utf-8"></script>
<script src="models/RelationModel.js" charset="utf-8"></script>
<script src="models/graphVertex.js"></script>
<script src="models/graph.js"></script>
<script type="text/javascript" src="jquery.js"></script>

<style type="text/css">
    .section {
        width: 600px;
        padding: 40px;
    }

    #canvas {
        border: 1px dashed;
    }


    .button {
        padding: 10px 15px;
        background: #ccc;
        border-radius: 5px;
        width: max-content;
        margin-top: 15px;
    }

    .button:hover {
        transition: 0.5s;
        cursor: pointer;
        background: #fcc;
    }

    .cont-button {
        margin-top: 20px;
    }

    .inputCell {
        width: 30px;
    }

    .error {
        width: 30px;
        background-color: #f68686;
    }

    .errorField {
        background-color: #f68686;
    }

    .correct {
        width: 30px;
        background-color: #8bf783;
    }

    .correctField {
        background-color: #8bf783;
    }
</style>

<body>
    <form action="/models/train4" method="post" id="train2">
        <label class="label">
            <span><b>Дано множество:</b></span>
            <p id="A"></p>
            <span><b>Дано отношение:</b></span>
            <p id="rel"></p>
        </label>
    </form>

    <p id="current-task"></p>

    <div class="section" id="section">
        <canvas id="canvas">
        </canvas>
    </div>

    <div class="cont-button">
        <div id='give-desicion' class="button">
            Решить
        </div>
        <div class="result">
        </div>
        <div id='continue' class="button">
            Дальше
        </div>
    </div>
</body>

<script type="text/javascript">
    $('#continue').hide();
    document.getElementById("current-task").innerHTML = "<b>Шаг 1: Изобразите отношение в виде графа<b>";

    let equivMat, partMat, linearMat, strictMat, strictLinMat;
    let adjacCopy;

    let step = 0;

    const graphSize = 5;

    var canvas = document.getElementById("canvas");

    let graph = new Graph(graphSize, graphSize + 1, 200, 15, 1, 1, 1);

    function changeWidthCanvas() {
        context = canvas.getContext("2d");
        var sectionSize = document.getElementById("section").getBoundingClientRect();
        canvas.setAttribute('width', sectionSize.width);
        canvas.setAttribute('height', 600);
    }

    changeWidthCanvas();

    $(window).resize(function() {
        changeWidthCanvas();
        graph.createVertex(canvas);
        graph.draw(canvas);
    });

    graph.createVertex(canvas);
    graph.setAdjacZero();
    graph.draw(canvas);

    canvas.addEventListener("click", createEdge, false);

    function getCursorPos(e) {
        let x, y;
        if (e.PageX != undefined && e.pageY != undefined) {
            x = e.pageX;
            y = e.pageY;
        } else {
            x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }

        return [x, y];
    }

    function createEdge(e) {
        let pos = getCursorPos(e);
        graph.checkClick(pos[0] - this.offsetLeft, pos[1] - this.offsetTop, canvas);
    }

    let U = new Set(8),
        A = new Set(graphSize, ["A", "B", "C", "D", "E"]);
    let rel = new Relation(A, 3);

    document.getElementById("A").innerHTML = "{" + A.getStr(",") + "}";

    document.getElementById("rel").innerHTML = "{" + rel.getRel().map(x => " (" + x.getStr(",") + ")") + "}";

    $('#give-desicion').on('click', function() {

        let err = true;

        if (step == 0) {
            for (let r of rel.relation) {
                for (let i = 0; i < graph.countVertex; i++) {
                    for (let j = 0; j < graph.countVertex; j++) {
                        if (graph.adjac[i][j]) {
                            if (String.fromCharCode(graph.vertex[i].name) == r.elems[0]) {
                                if (String.fromCharCode(graph.vertex[j].name) == r.elems[1]) {
                                    err = false;
                                    break;
                                } else err = true;
                            }
                        }
                    }
                }
            }
        } else if (step == 1) {
            err = false;
            for (let i = 0; i < graph.countVertex; i++) {
                for (let j = 0; j < graph.countVertex; j++) {
                    if (equivMat[i][j] != graph.adjac[i][j]) {
                        err = true;
                    }
                }
            }
        }

        if (err) {
            $('.result').text('Неверно').css({
                'color': 'red'
            });
            $('#give-desicion').hide();
            return 0;
        }

        $('.result').text('Верно').css({
            'color': 'green'
        });
        $('#give-desicion').hide();
        $('#continue').show();
    });

    $('#continue').on('click', function() {
        if (step == 0) {
            adjacCopy = new Array();
            for (var i = 0; i < graph.countVertex; i++) {
                adjacCopy[i] = new Array(graph.countVertex);
            }
            for (let i = 0; i < graph.countVertex; i++) {
                for (let j = 0; j < graph.countVertex; j++) {
                    if (graph.adjac[i][j]) {
                        adjacCopy[i][j] = 1;
                    } else adjacCopy[i][j] = 0;
                }
            }
        }
        step++;
        console.log("kek");
        $('#continue').hide();
        $('.result').empty();
        $('#give-desicion').show();
        if (step == 1) {
            document.getElementById("current-task").innerHTML = "<b>Шаг 2: Достройте до отношения эквивалентности и выпишите фактор-множество<b>";

            equivMat = new Array();
            for (var i = 0; i < graph.countVertex; i++) {
                equivMat[i] = new Array(graph.countVertex);
            }
            for (let i = 0; i < graph.countVertex; i++) {
                for (let j = 0; j < graph.countVertex; j++) {
                    if (adjacCopy[i][j]) {
                        equivMat[i][j] = 1;
                    } else equivMat[i][j] = 0;
                }
            }
            //сначала находим транизитивность для построенного графа
            for (let i = 0; i < graph.countVertex; i++) {
                for (let j = 0; j < graph.countVertex; j++) {
                    if (equivMat[i][j]) {
                        for (let k = 0; k < graph.countVertex; k++) {
                            if (equivMat[j][k]) {
                                equivMat[i][k] = 1;
                                equivMat[k][i] = 1;
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < graph.countVertex; i++) {
                for (let j = 0; j < graph.countVertex; j++) {
                    //делаем его симметричным
                    if (equivMat[i][j]) {
                        equivMat[j][i] = 1;
                    }
                    //делаем его рефликсивным
                    if (!equivMat[i][j] && i == j) {
                        equivMat[i][j] = 1;
                    }
                    //и делаем его снова тразитивным ибо предыдущий поиск транзитивности
                    //а так же симметричности могли добавить ещё транзитивностей
                    //и я ебал
                    if (equivMat[i][j]) {
                        for (let k = 0; k < graph.countVertex; k++) {
                            if (equivMat[j][k]) {
                                equivMat[i][k] = 1;
                            }
                        }
                    }
                }
            }
            console.log(equivMat);

        } else if (step == 2) {
            document.getElementById("current-task").innerHTML = "<b>Шаг 3: Достройте до отношения частичного порядка и выпишите минимальные и максимальные элементы<b>";

            for (let i = 0; i < graph.countVertex; i++) {
                for (let j = 0; j < graph.countVertex; j++) {
                    if (partMat[i][j]) {
                        partMat[j][i] = 1;
                    }
                    if (partMat[i][j] && i == j) {
                        partMat[i][j] = 0;
                    }
                    if (partMat[i][j]) {
                        for (let k = 0; k < graph.countVertex; k++) {
                            if (partMat[j][k]) {
                                partMat[i][k] = 1;
                                partMat[k][i] = 1;
                            }
                        }
                    }
                }
            }

            console.log("lol");
        } else if (step == 3) {
            document.getElementById("current-task").innerHTML = "<b>Шаг 3: Достройте до отношения линейного порядка и выпишите минимальный и максимальный элемент<b>";
            console.log("lol");
        } else if (step == 4) {
            document.getElementById("current-task").innerHTML = "<b>Шаг 4: Достройте до отношения строгого порядка<b>";
            console.log("lol");
        } else if (step == 5) {
            document.getElementById("current-task").innerHTML = "<b>Шаг 4: Достройте до отношения строгого линейного порядка<b>";
            console.log("lol");
        }
    });
</script>